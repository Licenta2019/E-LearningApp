Care dintre urmatoarele afirmatii sunt adevarate cu privire la modificatorul final?|1|Metodele final nu mai pot fi redefinite in clasele derivate.t|Atributele si variabile locale trebuie initializate la declarare.t|Clasele final pot fi extinse.f|Doar tipurile primitive de date pot primi modificatorul final.f|Daca o metoda are modificatorul final aceasta nu mai poate fi redefinita in clasele derivate.Modificatorul final folosit in cazul variabilelor/atributelor face variabila constanta deci trebuie initializata la declarare.Daca o clasa are modificatorul final aceasta nu poate fi extinsa #
class A{
    private int x;
    public A(){x=1;}
    public A(int val){x=2*val;}
    public int getVal(){
        return x;
    }
}

class B extends A{
    public B(){super(1);}
    public B(int val){}
}

class Main{
    public static void main(String []args){
        A[] vect = new A[4];
        vect[0] = new A();
        vect[1] = new B();
        vect[2] = new A(5);
        vect[3] = new B(6);
        int s = 0;
        for(A a:vect) {
            s = s + a.getVal();
        }
        System.out.println(s);
    }
} Ce se afiseaza?|eroaref|14t|13f|25f|se apeleaza constructorul default de la A => x=1se apeleaza constructorul default de la B, iar apoi se apeleaza constructorul cu parametru int din superclasa A => x=2*1=2
se apeleaza constructorul cu parametru int din clasa A => x=2*5=10
se apeleaza constructorul cu parametru int din clasa B, iar apoi constructorul default din superclasa A (deoarece nu se apeleaza explicit altul) => x=1
rezultat : 14=1+2+10+1 #
public class GrilaClass
{
    public GrilaClass(ArrayList<Integer> list)
    {
        System.out.println("ArrayList constructor");
    }

    public GrilaClass(List<Integer> list)
    {
        System.out.println("List constructor");
    }
}

public class Main
{
    public static void main(String[] args)
    {
        List<Integer> list=new ArrayList<>();
        GrilaClass grilaClass=new GrilaClass(list);
    }
}

Ce se afiseaza?|1|
ArrayList constructorf|
List constructort|
nimicf|
eroaref|
Desi list este un ArrayList, el este declarat de tip List, motiv pentru care se va apela constructorul lui GrilaClass cu parametru de tip List. #
Ce se afiseaza la rularea codului urmator?

public abstract class Shape{
    private String name;
    public Shape(String name){
        this.name = name;
    };
    abstract double Area();
}

public class Square extends Shape {
    private double sideLength = 0;
    public Square(String name, double sideLength) {
        this.sideLength = sideLength;
        super(name);
    }
    @Override
    double Area() {
        return this.sideLength * this.sideLength;
    }
}

 public static void main(String[] args) {

        Shape s = new Square("Awesome square.", 3.14);
        System.out.println(s.Area());
}|1|
3.14f|
eroaret|
0f|
9.8596f|
Pentru a apela, din constructorul clasei derivate, un constructor al clasei de
baza, apelul acestui constructor este prima instructiune din constructorul clasei 
derivate. #
Ce va afisa urmatorul program?
public class Main {

    public static void main(String[] args) {
        Ying ying = Ying.getInstance();
    }
}
class Ying{

    private Ying(){
        System.out.print("A");
    }

    static {
        System.out.print("B");
    }

    private static class Yang{

        static {
            System.out.print("C");
        }
        private static final Ying ying = new Ying();
        static {
            System.out.print("D");
        }
    }

    public static Ying getInstance(){
        System.out.print("E");
        return Yang.ying;
    }

    static {
        System.out.print("F");
    }

}|3|
ABFECDf|
BECADFf|
BFECADt|
ABECDFf|
    Blocurile statice se executa
        -inaintea functiilor statice,
        -inaintea unu constructor(deci si a functiilor de instanta)
        -in ordinea in care au fost scrise
    Ordinea corecta:
    B - blocul static
    F - blocul static
    E - metoda getInstance
    C - blocul static
    A - constructor
    D - bloc static #

Ce afiseaza programul urmator?
public class Stack<E> {
    private E[] items = new E[100]();
    private int size = 0;

    public void push(E e){
        items[size] = e;
        size += 1;
    }

    public E pop(){
        size -=1;
        E e = items[size];
        items[size] = null;
        return e;
    }
}

// intr-o metoda main
Stack<Integer> e = new Stack<>();
e.push(10);
e.push(5);
System.out.println(e.pop());|3|
5f|
10f|
Errort|
5 10f|
private E[] items = new E[100](); // eroare
E[] items=(E[])new Object[20]; //O varianta corecta de a rescrie linia de cod #

Ce afiseaza programul urmator?
// intr-o metoda main
Person s = new Student("Alice");
Person p = new Person("Bob");
InfoManager m = new InfoManager();
System.out.println(m.printInfo(s) +"; " + m.printInfo(p));
 
// in clasa InfoManager
public String printInfo(Person p){
  return "Person " + p.getName();
}
 
public String printInfo(Student s){
  return "Student " + s.getName();
}|1|

Person Bob; Student Alicef|
Person Alice; Person Bobt|
Student Alice; Student Bobf|
Student Alice; Person Bobf|

Si s si p sunt de tipul Person chiar daca s este un pointer spre tipul Student#

Avand un container generic de tipul stiva
(declarat Stack<Integer> stack = new Stack<Integer>();)
care dintre urmatoarele instructiuni nu poate fi folosita pentru adaugarea unui intreg?|3|

stack.push(new Integer(10))f|
stack.push(10);f|
int a=10;
stack.push(a);f|
toate metodele mentionate anterior sunt corectet|
Toate metodele enumerate mai sus sunt corecte. #

Un obiect de tipul singleton trebuie sa aiba doar 2 functii: constructorul si functia getInstance.
Cum arata antetul acestor functii?|1|
public static Singleton(){...};
public static Singleton getInstance(){...};f|

private static Singleton(){...}; 
public static Singleton getInstance(){...};t|

public static Singleton(){...};
private static Singleton getInstance(){...};f|

private static Singleton(){...}; 
private static Singleton getInstance(){...};f|

Constructorul este privat iar metoda get este publica. #

Fie urmatorul proram JAVA:
int x=0;
if (Double.isInfinite(2/x))
System.out.println(“Infinit”);
else
System.out.println(“2/0”);

Ce se poate spune despre acesta? |4|
eroare la compilare din cauza impartirii cu 0f|
eroare la executia programului din cauza impartirii cu 0(Arithmetic Exception)t|
programul va afisa “Infinit”f|
programul va afisa “2/0”f|
Proramul,la excutie va arunca Arithmetic Exception,din cauza impartirii cu 0.Eroarea nu se va intampla la compilare deoarece codul este corect,din punct de vedere al sintaxei.#

Fiind date clasele :

public abstract class Fruit(){
    	@Override String toString(){
    		return "Fruit";
    	}
    }
    public class Apple implements Fruit{
        @Override String toString(){
            return "Apple";
        }
    }
    public class Pear implements Fruit{
        @Override String toString(){
            return "Pear";
        }
    }

    List basket = new ArrayList<>();
    basket.add(new Apple());
    basket.add(new Pear());
    basket.add(new Apple());
    List<? extends Fruit> fridge = new ArrayList<>(basket);
    fridge.forEach(fruit->System.out.print(fruit + " "));
    List<? extends Fruit> store = new ArrayList<>(10);
    Collections.copy(store, basket);
    store.forEach(fruit->System.out.print(fruit + " "));

Care este rezultatul executiei codului de mai sus?|4|

Apple Pear Apple Apple Pear Applef|
exceptie la "Collections.copy(store, basket)"t|
Fruit Fruit Fruit Fruit Fruit Fruitf|
eroare la "new ArrayList<>(basket)"f|
eroare la "Collections.copy" exceptie la runtime java.lang.IndexOutOfBoundsException: Source does not fit in dest#

Dată fiind expresia de constrângeri:
 T extends C & I1 & I2
cu ce element este înlocuit T la compilare?|3|
Ct|
I2f|
I1 & I2f|
C & I1 & I2f|
C deoarece la compilare, T este înlocuit cu primul element din expresia de constrângeri#

Ce se intampla la rularea urmatorului cod?

String[] strings={“hello”,”world”};
Object[] obj=strings;
List<?>list=new ArrayList<Object>();
For (Object o:obj){
	System.out.println(obj);
	list.add(o);|3|
eroare de compilare la linia 6f|
afișează “hello” și “world” pe linii diferitet|
eroare de compilare la linia 2f|
eroare de compilare la linia 3f|
Linia 2 e corectă sintactic, deși dacă apoi încercăm ceva de tipul objects[1] = 1 vom obține un ArrayStoreException la runtime. Linia 3 e perfect în regulă, pentru că ArrayList implementează List și wildcard-ul se potrivește cu Object. Ce nu putem face e să apelăm metoda add pe variabila list, pentru că la compilare nu se cunoaște tipul obiectelor conținute în listă. Doar null poate fi folosit ca parametru, pentru că null aparține oricărui tip referință. #

Clasele Helper diferă de clasele Factory prin faptul că:|4|
Nu diferăf|
Clasa Helper se concentrează pe crearea de obiectef|
Clasa Helper se concentrează asupra manipulării obiectelor claselor existentet|
Clasa Helper mostenesc clasele factoryf|

Clasele helper și clasele factory sunt asemănătoare prin faptul că acestea sunt adesea compuse din metode statice are operează pe o anumită clasă, dar ele diferă prin scopul lor, astfel că clasele helper se concentrează asupra manipulării datelor, în timp ce clasele factory se concentrează pe crearea lor. (Curs 4 - pagina 50)#

Ce se afișează la rularea codului urmator? Explicați.

class Litere {
    String str = "a";
    void A(){
        try{
            str += "b";
            B();
        }
        catch (Exception e){
            str += "c";
        }
    }
    void B() throws Exception{
        try{
            str += "d";
            C();
        }
        catch (Exception e){
            throw new Exception();

        }
        finally {
            str += "e";
        }

        str += "f";
    }
    void C() throws Exception{
        str += "g";
        throw new Exception();
    }
    void afisare(){
        System.out.println(str);
    }
    public static void main(String[] args){
        Litere lit = new Litere();
        lit.A();
        lit.afisare();
    }
}|4|
abcdegf|
abdefgf|
abdgect|
abdfgcf|
Se apelează funcția A, se adaugă litera „b”, apoi se apelează funcția B, unde se adaugă litera „d” și se apelează funcția C, unde se adaugă litera „g”, iar instrucțiunea throw aruncă o excepție care este prinsă in funcția B prin instrucțiunea catch, care aruncă o nouă excepție, se adaugă în variabila str litera „e” prin blocul finally deoarece se apeleaza indiferent dacă este prinsă o excepție sau nu, apoi excepția din funcția B este prinsă în funcția A, unde se adaugă litera „c”, varibila str devenind în final abdgec. #
